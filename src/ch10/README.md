# 第十章 转移指令的原理

### 内容

- ret & retf

  - ret
    - 用栈中的数据修改 IP，实现近转移
    - 相当于 `pop IP`
  - retf
    - 用栈中的数据修改 IP 和 CS，实现远转移
    - 相当于 `pop IP`+`pop CS`

- call 指令

  - 机制：将当前的 IP 或 CS 和 IP 压栈=>转移
  - call 不能实现短转移（？）
  - 种类：
    - `call 标号`：段内转移
      - 将当前的 IP（其实是当前执行的指令所在行的下一行，记住 CPU 是先取下一行指令，然后执行该行指令！）压栈，转到标号处执行指令
      - 相当于 `push IP` + `jmp near ptr 标号`
    - `call far ptr 标号`：段间转移
      - 将 CS 和 IP 压栈，转移
      - 相当于 `push CS` + `push IP` + `jmp far ptr 标号`(注意 push 的顺序)
    - `call 16位reg`
      - 相当于`push IP` + `jmp 16位reg`
    - `call word ptr 内存单元地址`
      - 相当于 `push IP` + `jmp word ptr 内存单元地址`
    - `call dword ptr 内存单元地址`
      - 相当于 `push CS` + `push IP` + `jmp dword ptr 内存单元地址`

- call & ret：call 指令转去执行子程序之前，call 指令后面的指令的地址将存储在栈中。而在子程序的后面使用 ret 指令，用栈中的数据设置 IP 的值，从而转到 call 指令后面的代码处继续执行。

- mul 指令

  - 格式：
    - `mul reg`
    - `mul 内存单元`
  - 要么都是 8 位要么都是 16 位
  - 都是 8 位：一个默认在 al 中，另一个在 8 位 reg 中或内存**字节**单元中
  - 都是 16 位：一个默认在 ax 中，另一个在 16 位 reg 中或内存**字**单元中

- 模块化程序设计
  - 参数传递
    - 寄存器传递数据
    - 数据放到内存中，使用寄存器传递内存空间的首地址
    - 寄存器冲突问题：寄存器入栈出栈

### 检测点 10.1

```
1000H
0
```

### 检测点 10.2

```
ax = 6
```

### 检测点 10.3

```
ax = 1010h
```

### 检测点 10.4

```
ax = 000bh
```

### 检测点 10.5

- (1)
  [代码](./J10-5_1.ASM)

注意：这里栈段和数据段是同一个！

TODO
疑问：这里为什么不能用 Debug 调试呢？（感觉个 P74 页的那个问题是同一个，都是由 `mov ss,ax`这句直接导致的）

```
ax = 3
```

-(2)

[代码](./J10-5_2.ASM)

```
ax = 1, bx= 0
```
