# 第六章 包含多个段的程序

### 内容

- `dw`：定义字型数据
- `db` 定义字节型数据(ch07)
- `dd`：定义双字型数据(ch08)

- `end`

  - 通知编译器程序结束
  - 告知编译器程序的入口

- 分段

  - 数据、栈、代码分段
  - 如果所需要的空间超过 64KB，就不能放在同一个段中，因为 8086 中一个段的容量不能大于 64KB
  - 段名相当于一个标号，代表了段地址

- `assume` 并不会主动将 cs,ds,ss 分别和我们定义的 code,data,stack 相连，因为它是伪指令，是由编译器执行的而非 CPU 执行。

  - CPU 对我们定义于段中的内容当做数据、指令、还是栈空间，仅仅由 CS:IP, SS:SP,DS 等寄存器的设置来决定
  - 其中和 `code` 相联系的 `cs` 寄存器，由于在程序末尾我们使用了`end start`，因此 `cs` 被指定为这个入口
  - 和`data`相关联的`ds`，需要我们在程序中手动指定，常见的做法是`mov ax,data` `mov ds,ax`
  - 和`stack`相关联的`ss`，需要我们在程序中手动指定，常见的做法是`mov ax,stack` `mov ss,ax`

- `mov ss,cs` 是非法操作(编译报错)，但是尚未在书中找到相关说明

- 对于程序中的段名（相当于标号），如 `data segment....data ends` 中的 `data`，将被编译器处理为一个表示段的地址（数值），因此也不能使用 `mov ds,data` 之类的方式，仍然应使用 `ax` 寄存器中转：`mov ax,data` `mov ds,ax`

### 检测点 6.1

- (1)
  [checkpoint_6_1_1.asm](./checkpoint_6_1_1.asm)
- (2)
  [checkpoint_6_1_2.asm](./checkpoint_6_1_2.asm)

### 实验 5

- (1)
  - 代码 [lab5_1](./LAB5_1.ASM)
  - 答案：
    - 1. 就是那些数据
    - 2. 我的机器上面，cs=0774，ss=0773，ds=0772 (使用 debug 中 `-u 0774:0` 可查看到编译器将 stack 和 data 分别转换为相应的地址)
    - 3. x-2，x-1
- (2)
  - 代码 [lab5_2](./LAB5_2.ASM)
  - 答案：
    - 1. 就是那些数据
    - 2. 和(1) 一样
    - 3. x-2，x-1
         不过不同的是，这个程序运行完成后，stack 段的内容发生了变化，原因不知（
- (3)
  - 代码 [lab5_3](./LAB5_3.ASM)
  - 答案：
    - 1. 就是那些数据
    - 2. 我的机器上面，cs=0772，ss=0776，ds=0775 (使用 debug 中 `-u 0772:0` 可查看到编译器将 stack 和 data 分别转换为相应的地址)
    - 3. x+3，x+4
- (4)
  (3) 仍然可以正确运行
- (5)
  [lab5_5](./LAB5_5.ASM)
- (6)
  [lab5_6](./LAB5_6.ASM)
